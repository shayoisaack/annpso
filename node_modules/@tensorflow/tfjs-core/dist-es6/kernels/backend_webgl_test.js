import * as tf from '../index';
import { describeWithFlags } from '../jasmine_util';
import { expectArraysClose, expectArraysEqual, WEBGL_ENVS } from '../test_util';
import { MathBackendWebGL } from './backend_webgl';
describeWithFlags('backendWebGL', WEBGL_ENVS, function () {
    it('delayed storage, reading', function () {
        var delayedStorage = true;
        var backend = new MathBackendWebGL(null, delayedStorage);
        var texManager = backend.getTextureManager();
        var dataId = {};
        backend.register(dataId, [3], 'float32');
        backend.write(dataId, new Float32Array([1, 2, 3]));
        expect(texManager.getNumUsedTextures()).toBe(0);
        backend.getTexture(dataId);
        expect(texManager.getNumUsedTextures()).toBe(1);
        expectArraysClose(backend.readSync(dataId), new Float32Array([1, 2, 3]));
        expect(texManager.getNumUsedTextures()).toBe(0);
        backend.getTexture(dataId);
        expect(texManager.getNumUsedTextures()).toBe(1);
        backend.disposeData(dataId);
        expect(texManager.getNumUsedTextures()).toBe(0);
    });
    it('delayed storage, overwriting', function () {
        var delayedStorage = true;
        var backend = new MathBackendWebGL(null, delayedStorage);
        var texManager = backend.getTextureManager();
        var dataId = {};
        backend.register(dataId, [3], 'float32');
        backend.write(dataId, new Float32Array([1, 2, 3]));
        backend.getTexture(dataId);
        expect(texManager.getNumUsedTextures()).toBe(1);
        backend.write(dataId, new Float32Array([4, 5, 6]));
        expect(texManager.getNumUsedTextures()).toBe(0);
        expectArraysClose(backend.readSync(dataId), new Float32Array([4, 5, 6]));
        backend.getTexture(dataId);
        expect(texManager.getNumUsedTextures()).toBe(1);
        expectArraysClose(backend.readSync(dataId), new Float32Array([4, 5, 6]));
        expect(texManager.getNumUsedTextures()).toBe(0);
    });
    it('immediate storage reading', function () {
        var delayedStorage = false;
        var backend = new MathBackendWebGL(null, delayedStorage);
        var texManager = backend.getTextureManager();
        var dataId = {};
        backend.register(dataId, [3], 'float32');
        backend.write(dataId, new Float32Array([1, 2, 3]));
        expect(texManager.getNumUsedTextures()).toBe(1);
        expectArraysClose(backend.readSync(dataId), new Float32Array([1, 2, 3]));
        expect(texManager.getNumUsedTextures()).toBe(1);
        backend.disposeData(dataId);
        expect(texManager.getNumUsedTextures()).toBe(0);
    });
    it('immediate storage overwriting', function () {
        var delayedStorage = false;
        var backend = new MathBackendWebGL(null, delayedStorage);
        var texManager = backend.getTextureManager();
        var dataId = {};
        backend.register(dataId, [3], 'float32');
        backend.write(dataId, new Float32Array([1, 2, 3]));
        expect(texManager.getNumUsedTextures()).toBe(1);
        backend.write(dataId, new Float32Array([4, 5, 6]));
        expect(texManager.getNumUsedTextures()).toBe(1);
        expectArraysClose(backend.readSync(dataId), new Float32Array([4, 5, 6]));
        expect(texManager.getNumUsedTextures()).toBe(1);
        backend.disposeData(dataId);
        expect(texManager.getNumUsedTextures()).toBe(0);
    });
    it('disposal of backend disposes all textures', function () {
        var delayedStorage = false;
        var backend = new MathBackendWebGL(null, delayedStorage);
        var texManager = backend.getTextureManager();
        var dataId = {};
        backend.register(dataId, [3], 'float32');
        backend.write(dataId, new Float32Array([1, 2, 3]));
        var dataId2 = {};
        backend.register(dataId2, [3], 'float32');
        backend.write(dataId2, new Float32Array([4, 5, 6]));
        expect(texManager.getNumUsedTextures()).toBe(2);
        backend.dispose();
        expect(texManager.getNumUsedTextures()).toBe(0);
    });
});
describe('Custom window size', function () {
    it('Set screen area to be 1x1', function () {
        spyOnProperty(window, 'screen', 'get')
            .and.returnValue({ height: 1, width: 1 });
        var oldBackend = tf.getBackend();
        tf.ENV.registerBackend('custom-webgl', function () { return new MathBackendWebGL(); });
        tf.setBackend('custom-webgl');
        var a = tf.ones([100, 100]);
        expect(tf.memory().numBytesInGPU).toBe(0);
        a.square();
        expect(tf.memory().numBytesInGPU).toBe(0);
        expectArraysEqual(a, new Float32Array(100 * 100).fill(1));
        tf.setBackend(oldBackend);
    });
});
//# sourceMappingURL=backend_webgl_test.js.map